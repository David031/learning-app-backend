module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDynasty {
  count: Int!
}

type AggregateIdiom {
  count: Int!
}

type AggregateLevel {
  count: Int!
}

type AggregateRecord {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Dynasty {
  id: ID!
  code: String!
  dynastyName: String!
  idioms(where: IdiomWhereInput, orderBy: IdiomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Idiom!]
}

type DynastyConnection {
  pageInfo: PageInfo!
  edges: [DynastyEdge]!
  aggregate: AggregateDynasty!
}

input DynastyCreateInput {
  id: ID
  code: String!
  dynastyName: String!
  idioms: IdiomCreateManyWithoutDynastyInput
}

input DynastyCreateOneInput {
  create: DynastyCreateInput
  connect: DynastyWhereUniqueInput
}

input DynastyCreateOneWithoutIdiomsInput {
  create: DynastyCreateWithoutIdiomsInput
  connect: DynastyWhereUniqueInput
}

input DynastyCreateWithoutIdiomsInput {
  id: ID
  code: String!
  dynastyName: String!
}

type DynastyEdge {
  node: Dynasty!
  cursor: String!
}

enum DynastyOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  dynastyName_ASC
  dynastyName_DESC
}

type DynastyPreviousValues {
  id: ID!
  code: String!
  dynastyName: String!
}

type DynastySubscriptionPayload {
  mutation: MutationType!
  node: Dynasty
  updatedFields: [String!]
  previousValues: DynastyPreviousValues
}

input DynastySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DynastyWhereInput
  AND: [DynastySubscriptionWhereInput!]
  OR: [DynastySubscriptionWhereInput!]
  NOT: [DynastySubscriptionWhereInput!]
}

input DynastyUpdateDataInput {
  code: String
  dynastyName: String
  idioms: IdiomUpdateManyWithoutDynastyInput
}

input DynastyUpdateInput {
  code: String
  dynastyName: String
  idioms: IdiomUpdateManyWithoutDynastyInput
}

input DynastyUpdateManyMutationInput {
  code: String
  dynastyName: String
}

input DynastyUpdateOneRequiredInput {
  create: DynastyCreateInput
  update: DynastyUpdateDataInput
  upsert: DynastyUpsertNestedInput
  connect: DynastyWhereUniqueInput
}

input DynastyUpdateOneRequiredWithoutIdiomsInput {
  create: DynastyCreateWithoutIdiomsInput
  update: DynastyUpdateWithoutIdiomsDataInput
  upsert: DynastyUpsertWithoutIdiomsInput
  connect: DynastyWhereUniqueInput
}

input DynastyUpdateWithoutIdiomsDataInput {
  code: String
  dynastyName: String
}

input DynastyUpsertNestedInput {
  update: DynastyUpdateDataInput!
  create: DynastyCreateInput!
}

input DynastyUpsertWithoutIdiomsInput {
  update: DynastyUpdateWithoutIdiomsDataInput!
  create: DynastyCreateWithoutIdiomsInput!
}

input DynastyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  dynastyName: String
  dynastyName_not: String
  dynastyName_in: [String!]
  dynastyName_not_in: [String!]
  dynastyName_lt: String
  dynastyName_lte: String
  dynastyName_gt: String
  dynastyName_gte: String
  dynastyName_contains: String
  dynastyName_not_contains: String
  dynastyName_starts_with: String
  dynastyName_not_starts_with: String
  dynastyName_ends_with: String
  dynastyName_not_ends_with: String
  idioms_every: IdiomWhereInput
  idioms_some: IdiomWhereInput
  idioms_none: IdiomWhereInput
  AND: [DynastyWhereInput!]
  OR: [DynastyWhereInput!]
  NOT: [DynastyWhereInput!]
}

input DynastyWhereUniqueInput {
  id: ID
  code: String
}

type Idiom {
  id: ID!
  idiom: String!
  description: String!
  dynasty: Dynasty!
}

type IdiomConnection {
  pageInfo: PageInfo!
  edges: [IdiomEdge]!
  aggregate: AggregateIdiom!
}

input IdiomCreateInput {
  id: ID
  idiom: String!
  description: String!
  dynasty: DynastyCreateOneWithoutIdiomsInput!
}

input IdiomCreateManyInput {
  create: [IdiomCreateInput!]
  connect: [IdiomWhereUniqueInput!]
}

input IdiomCreateManyWithoutDynastyInput {
  create: [IdiomCreateWithoutDynastyInput!]
  connect: [IdiomWhereUniqueInput!]
}

input IdiomCreateWithoutDynastyInput {
  id: ID
  idiom: String!
  description: String!
}

type IdiomEdge {
  node: Idiom!
  cursor: String!
}

enum IdiomOrderByInput {
  id_ASC
  id_DESC
  idiom_ASC
  idiom_DESC
  description_ASC
  description_DESC
}

type IdiomPreviousValues {
  id: ID!
  idiom: String!
  description: String!
}

input IdiomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  idiom: String
  idiom_not: String
  idiom_in: [String!]
  idiom_not_in: [String!]
  idiom_lt: String
  idiom_lte: String
  idiom_gt: String
  idiom_gte: String
  idiom_contains: String
  idiom_not_contains: String
  idiom_starts_with: String
  idiom_not_starts_with: String
  idiom_ends_with: String
  idiom_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [IdiomScalarWhereInput!]
  OR: [IdiomScalarWhereInput!]
  NOT: [IdiomScalarWhereInput!]
}

type IdiomSubscriptionPayload {
  mutation: MutationType!
  node: Idiom
  updatedFields: [String!]
  previousValues: IdiomPreviousValues
}

input IdiomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IdiomWhereInput
  AND: [IdiomSubscriptionWhereInput!]
  OR: [IdiomSubscriptionWhereInput!]
  NOT: [IdiomSubscriptionWhereInput!]
}

input IdiomUpdateDataInput {
  idiom: String
  description: String
  dynasty: DynastyUpdateOneRequiredWithoutIdiomsInput
}

input IdiomUpdateInput {
  idiom: String
  description: String
  dynasty: DynastyUpdateOneRequiredWithoutIdiomsInput
}

input IdiomUpdateManyDataInput {
  idiom: String
  description: String
}

input IdiomUpdateManyInput {
  create: [IdiomCreateInput!]
  update: [IdiomUpdateWithWhereUniqueNestedInput!]
  upsert: [IdiomUpsertWithWhereUniqueNestedInput!]
  delete: [IdiomWhereUniqueInput!]
  connect: [IdiomWhereUniqueInput!]
  set: [IdiomWhereUniqueInput!]
  disconnect: [IdiomWhereUniqueInput!]
  deleteMany: [IdiomScalarWhereInput!]
  updateMany: [IdiomUpdateManyWithWhereNestedInput!]
}

input IdiomUpdateManyMutationInput {
  idiom: String
  description: String
}

input IdiomUpdateManyWithoutDynastyInput {
  create: [IdiomCreateWithoutDynastyInput!]
  delete: [IdiomWhereUniqueInput!]
  connect: [IdiomWhereUniqueInput!]
  set: [IdiomWhereUniqueInput!]
  disconnect: [IdiomWhereUniqueInput!]
  update: [IdiomUpdateWithWhereUniqueWithoutDynastyInput!]
  upsert: [IdiomUpsertWithWhereUniqueWithoutDynastyInput!]
  deleteMany: [IdiomScalarWhereInput!]
  updateMany: [IdiomUpdateManyWithWhereNestedInput!]
}

input IdiomUpdateManyWithWhereNestedInput {
  where: IdiomScalarWhereInput!
  data: IdiomUpdateManyDataInput!
}

input IdiomUpdateWithoutDynastyDataInput {
  idiom: String
  description: String
}

input IdiomUpdateWithWhereUniqueNestedInput {
  where: IdiomWhereUniqueInput!
  data: IdiomUpdateDataInput!
}

input IdiomUpdateWithWhereUniqueWithoutDynastyInput {
  where: IdiomWhereUniqueInput!
  data: IdiomUpdateWithoutDynastyDataInput!
}

input IdiomUpsertWithWhereUniqueNestedInput {
  where: IdiomWhereUniqueInput!
  update: IdiomUpdateDataInput!
  create: IdiomCreateInput!
}

input IdiomUpsertWithWhereUniqueWithoutDynastyInput {
  where: IdiomWhereUniqueInput!
  update: IdiomUpdateWithoutDynastyDataInput!
  create: IdiomCreateWithoutDynastyInput!
}

input IdiomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  idiom: String
  idiom_not: String
  idiom_in: [String!]
  idiom_not_in: [String!]
  idiom_lt: String
  idiom_lte: String
  idiom_gt: String
  idiom_gte: String
  idiom_contains: String
  idiom_not_contains: String
  idiom_starts_with: String
  idiom_not_starts_with: String
  idiom_ends_with: String
  idiom_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  dynasty: DynastyWhereInput
  AND: [IdiomWhereInput!]
  OR: [IdiomWhereInput!]
  NOT: [IdiomWhereInput!]
}

input IdiomWhereUniqueInput {
  id: ID
}

type Level {
  id: ID!
  code: Int!
  name: String!
  idioms(where: IdiomWhereInput, orderBy: IdiomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Idiom!]
  dynasty: Dynasty!
  records(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Record!]
}

type LevelConnection {
  pageInfo: PageInfo!
  edges: [LevelEdge]!
  aggregate: AggregateLevel!
}

input LevelCreateInput {
  id: ID
  code: Int!
  name: String!
  idioms: IdiomCreateManyInput
  dynasty: DynastyCreateOneInput!
  records: RecordCreateManyWithoutLevelInput
}

input LevelCreateOneInput {
  create: LevelCreateInput
  connect: LevelWhereUniqueInput
}

input LevelCreateOneWithoutRecordsInput {
  create: LevelCreateWithoutRecordsInput
  connect: LevelWhereUniqueInput
}

input LevelCreateWithoutRecordsInput {
  id: ID
  code: Int!
  name: String!
  idioms: IdiomCreateManyInput
  dynasty: DynastyCreateOneInput!
}

type LevelEdge {
  node: Level!
  cursor: String!
}

enum LevelOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
}

type LevelPreviousValues {
  id: ID!
  code: Int!
  name: String!
}

type LevelSubscriptionPayload {
  mutation: MutationType!
  node: Level
  updatedFields: [String!]
  previousValues: LevelPreviousValues
}

input LevelSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LevelWhereInput
  AND: [LevelSubscriptionWhereInput!]
  OR: [LevelSubscriptionWhereInput!]
  NOT: [LevelSubscriptionWhereInput!]
}

input LevelUpdateDataInput {
  code: Int
  name: String
  idioms: IdiomUpdateManyInput
  dynasty: DynastyUpdateOneRequiredInput
  records: RecordUpdateManyWithoutLevelInput
}

input LevelUpdateInput {
  code: Int
  name: String
  idioms: IdiomUpdateManyInput
  dynasty: DynastyUpdateOneRequiredInput
  records: RecordUpdateManyWithoutLevelInput
}

input LevelUpdateManyMutationInput {
  code: Int
  name: String
}

input LevelUpdateOneRequiredInput {
  create: LevelCreateInput
  update: LevelUpdateDataInput
  upsert: LevelUpsertNestedInput
  connect: LevelWhereUniqueInput
}

input LevelUpdateOneRequiredWithoutRecordsInput {
  create: LevelCreateWithoutRecordsInput
  update: LevelUpdateWithoutRecordsDataInput
  upsert: LevelUpsertWithoutRecordsInput
  connect: LevelWhereUniqueInput
}

input LevelUpdateWithoutRecordsDataInput {
  code: Int
  name: String
  idioms: IdiomUpdateManyInput
  dynasty: DynastyUpdateOneRequiredInput
}

input LevelUpsertNestedInput {
  update: LevelUpdateDataInput!
  create: LevelCreateInput!
}

input LevelUpsertWithoutRecordsInput {
  update: LevelUpdateWithoutRecordsDataInput!
  create: LevelCreateWithoutRecordsInput!
}

input LevelWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: Int
  code_not: Int
  code_in: [Int!]
  code_not_in: [Int!]
  code_lt: Int
  code_lte: Int
  code_gt: Int
  code_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  idioms_every: IdiomWhereInput
  idioms_some: IdiomWhereInput
  idioms_none: IdiomWhereInput
  dynasty: DynastyWhereInput
  records_every: RecordWhereInput
  records_some: RecordWhereInput
  records_none: RecordWhereInput
  AND: [LevelWhereInput!]
  OR: [LevelWhereInput!]
  NOT: [LevelWhereInput!]
}

input LevelWhereUniqueInput {
  id: ID
  code: Int
}

scalar Long

type Mutation {
  createDynasty(data: DynastyCreateInput!): Dynasty!
  updateDynasty(data: DynastyUpdateInput!, where: DynastyWhereUniqueInput!): Dynasty
  updateManyDynasties(data: DynastyUpdateManyMutationInput!, where: DynastyWhereInput): BatchPayload!
  upsertDynasty(where: DynastyWhereUniqueInput!, create: DynastyCreateInput!, update: DynastyUpdateInput!): Dynasty!
  deleteDynasty(where: DynastyWhereUniqueInput!): Dynasty
  deleteManyDynasties(where: DynastyWhereInput): BatchPayload!
  createIdiom(data: IdiomCreateInput!): Idiom!
  updateIdiom(data: IdiomUpdateInput!, where: IdiomWhereUniqueInput!): Idiom
  updateManyIdioms(data: IdiomUpdateManyMutationInput!, where: IdiomWhereInput): BatchPayload!
  upsertIdiom(where: IdiomWhereUniqueInput!, create: IdiomCreateInput!, update: IdiomUpdateInput!): Idiom!
  deleteIdiom(where: IdiomWhereUniqueInput!): Idiom
  deleteManyIdioms(where: IdiomWhereInput): BatchPayload!
  createLevel(data: LevelCreateInput!): Level!
  updateLevel(data: LevelUpdateInput!, where: LevelWhereUniqueInput!): Level
  updateManyLevels(data: LevelUpdateManyMutationInput!, where: LevelWhereInput): BatchPayload!
  upsertLevel(where: LevelWhereUniqueInput!, create: LevelCreateInput!, update: LevelUpdateInput!): Level!
  deleteLevel(where: LevelWhereUniqueInput!): Level
  deleteManyLevels(where: LevelWhereInput): BatchPayload!
  createRecord(data: RecordCreateInput!): Record!
  updateRecord(data: RecordUpdateInput!, where: RecordWhereUniqueInput!): Record
  updateManyRecords(data: RecordUpdateManyMutationInput!, where: RecordWhereInput): BatchPayload!
  upsertRecord(where: RecordWhereUniqueInput!, create: RecordCreateInput!, update: RecordUpdateInput!): Record!
  deleteRecord(where: RecordWhereUniqueInput!): Record
  deleteManyRecords(where: RecordWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  dynasty(where: DynastyWhereUniqueInput!): Dynasty
  dynasties(where: DynastyWhereInput, orderBy: DynastyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dynasty]!
  dynastiesConnection(where: DynastyWhereInput, orderBy: DynastyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DynastyConnection!
  idiom(where: IdiomWhereUniqueInput!): Idiom
  idioms(where: IdiomWhereInput, orderBy: IdiomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Idiom]!
  idiomsConnection(where: IdiomWhereInput, orderBy: IdiomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IdiomConnection!
  level(where: LevelWhereUniqueInput!): Level
  levels(where: LevelWhereInput, orderBy: LevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Level]!
  levelsConnection(where: LevelWhereInput, orderBy: LevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LevelConnection!
  record(where: RecordWhereUniqueInput!): Record
  records(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Record]!
  recordsConnection(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RecordConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Record {
  id: ID!
  user: User!
  level: Level!
  status: RecordStatus!
}

type RecordConnection {
  pageInfo: PageInfo!
  edges: [RecordEdge]!
  aggregate: AggregateRecord!
}

input RecordCreateInput {
  id: ID
  user: UserCreateOneWithoutRecordsInput!
  level: LevelCreateOneWithoutRecordsInput!
  status: RecordStatus!
}

input RecordCreateManyWithoutLevelInput {
  create: [RecordCreateWithoutLevelInput!]
  connect: [RecordWhereUniqueInput!]
}

input RecordCreateManyWithoutUserInput {
  create: [RecordCreateWithoutUserInput!]
  connect: [RecordWhereUniqueInput!]
}

input RecordCreateWithoutLevelInput {
  id: ID
  user: UserCreateOneWithoutRecordsInput!
  status: RecordStatus!
}

input RecordCreateWithoutUserInput {
  id: ID
  level: LevelCreateOneWithoutRecordsInput!
  status: RecordStatus!
}

type RecordEdge {
  node: Record!
  cursor: String!
}

enum RecordOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
}

type RecordPreviousValues {
  id: ID!
  status: RecordStatus!
}

input RecordScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: RecordStatus
  status_not: RecordStatus
  status_in: [RecordStatus!]
  status_not_in: [RecordStatus!]
  AND: [RecordScalarWhereInput!]
  OR: [RecordScalarWhereInput!]
  NOT: [RecordScalarWhereInput!]
}

enum RecordStatus {
  Finish_All
  Finish_Three
  Finish_Two
  Not_Finish
}

type RecordSubscriptionPayload {
  mutation: MutationType!
  node: Record
  updatedFields: [String!]
  previousValues: RecordPreviousValues
}

input RecordSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RecordWhereInput
  AND: [RecordSubscriptionWhereInput!]
  OR: [RecordSubscriptionWhereInput!]
  NOT: [RecordSubscriptionWhereInput!]
}

input RecordUpdateInput {
  user: UserUpdateOneRequiredWithoutRecordsInput
  level: LevelUpdateOneRequiredWithoutRecordsInput
  status: RecordStatus
}

input RecordUpdateManyDataInput {
  status: RecordStatus
}

input RecordUpdateManyMutationInput {
  status: RecordStatus
}

input RecordUpdateManyWithoutLevelInput {
  create: [RecordCreateWithoutLevelInput!]
  delete: [RecordWhereUniqueInput!]
  connect: [RecordWhereUniqueInput!]
  set: [RecordWhereUniqueInput!]
  disconnect: [RecordWhereUniqueInput!]
  update: [RecordUpdateWithWhereUniqueWithoutLevelInput!]
  upsert: [RecordUpsertWithWhereUniqueWithoutLevelInput!]
  deleteMany: [RecordScalarWhereInput!]
  updateMany: [RecordUpdateManyWithWhereNestedInput!]
}

input RecordUpdateManyWithoutUserInput {
  create: [RecordCreateWithoutUserInput!]
  delete: [RecordWhereUniqueInput!]
  connect: [RecordWhereUniqueInput!]
  set: [RecordWhereUniqueInput!]
  disconnect: [RecordWhereUniqueInput!]
  update: [RecordUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [RecordUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [RecordScalarWhereInput!]
  updateMany: [RecordUpdateManyWithWhereNestedInput!]
}

input RecordUpdateManyWithWhereNestedInput {
  where: RecordScalarWhereInput!
  data: RecordUpdateManyDataInput!
}

input RecordUpdateWithoutLevelDataInput {
  user: UserUpdateOneRequiredWithoutRecordsInput
  status: RecordStatus
}

input RecordUpdateWithoutUserDataInput {
  level: LevelUpdateOneRequiredWithoutRecordsInput
  status: RecordStatus
}

input RecordUpdateWithWhereUniqueWithoutLevelInput {
  where: RecordWhereUniqueInput!
  data: RecordUpdateWithoutLevelDataInput!
}

input RecordUpdateWithWhereUniqueWithoutUserInput {
  where: RecordWhereUniqueInput!
  data: RecordUpdateWithoutUserDataInput!
}

input RecordUpsertWithWhereUniqueWithoutLevelInput {
  where: RecordWhereUniqueInput!
  update: RecordUpdateWithoutLevelDataInput!
  create: RecordCreateWithoutLevelInput!
}

input RecordUpsertWithWhereUniqueWithoutUserInput {
  where: RecordWhereUniqueInput!
  update: RecordUpdateWithoutUserDataInput!
  create: RecordCreateWithoutUserInput!
}

input RecordWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  level: LevelWhereInput
  status: RecordStatus
  status_not: RecordStatus
  status_in: [RecordStatus!]
  status_not_in: [RecordStatus!]
  AND: [RecordWhereInput!]
  OR: [RecordWhereInput!]
  NOT: [RecordWhereInput!]
}

input RecordWhereUniqueInput {
  id: ID
}

type Subscription {
  dynasty(where: DynastySubscriptionWhereInput): DynastySubscriptionPayload
  idiom(where: IdiomSubscriptionWhereInput): IdiomSubscriptionPayload
  level(where: LevelSubscriptionWhereInput): LevelSubscriptionPayload
  record(where: RecordSubscriptionWhereInput): RecordSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  maxUnlockedLevel: Level!
  records(where: RecordWhereInput, orderBy: RecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Record!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  maxUnlockedLevel: LevelCreateOneInput!
  records: RecordCreateManyWithoutUserInput
}

input UserCreateOneWithoutRecordsInput {
  create: UserCreateWithoutRecordsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutRecordsInput {
  id: ID
  name: String!
  email: String!
  maxUnlockedLevel: LevelCreateOneInput!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  maxUnlockedLevel: LevelUpdateOneRequiredInput
  records: RecordUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
}

input UserUpdateOneRequiredWithoutRecordsInput {
  create: UserCreateWithoutRecordsInput
  update: UserUpdateWithoutRecordsDataInput
  upsert: UserUpsertWithoutRecordsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutRecordsDataInput {
  name: String
  email: String
  maxUnlockedLevel: LevelUpdateOneRequiredInput
}

input UserUpsertWithoutRecordsInput {
  update: UserUpdateWithoutRecordsDataInput!
  create: UserCreateWithoutRecordsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  maxUnlockedLevel: LevelWhereInput
  records_every: RecordWhereInput
  records_some: RecordWhereInput
  records_none: RecordWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    